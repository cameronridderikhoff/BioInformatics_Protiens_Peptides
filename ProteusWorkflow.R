# Cameron Ridderikhoff, University of Alberta, 2020

# To see some information pertaining to the following code,
# Run the command:
# >vignette("proteus", package="proteus")

#SECTION: Imports
# libary(x) tells R what library, or set of functions, it needs to use.
library(proteus) # For proteus functions like: readProteinGroups, limmaDE, and more.
library(ggplot2) # For scatter, box, and Volcano plots, and saving of the plots.
#library(cowplot)
library(dplyr) # dplyr contains many helper functions required for this code.
library(pheatmap) # For the creation of a pheatmap.
library(SetRank) # For creating gene enrichment statistics.
library(biomaRt) # To help with SetRank, converts AGI protein IDs to Entrez.
# To help with SetRank, these Genesets are required, and must be generated by the user. 
# To generate this, run the command:
# >??SetRank
# and select the SetRank::vignette. Go to section 3.1.1, "Using the GeneSets package"
library(GeneSets.Arabidopsis.thaliana) 

# import the modified functions needed for this script
source("functions.R")

# import the conditions and number of samples from the Python script that runs this workflow "run_proteus_workflow.py"
args <- commandArgs()
conditions <- args[-(1:8)] # exclude the entries not pertaining to input values
control_condition <- args[8] # the control condition is located at index 8
num_samples <- args[9] # the number of samples is located at index 9


#SECTION: Read input data

# read the metadata file
meta <- read.delim("/Users/cameronridderikhoff/Documents/CMPUT399/BioInformatics_Protiens_Peptides/proteus_data/practice_data_files/TP_XYZ/txt/meta.txt", header = TRUE, sep = "\t", dec = ".")

# (Section 5.5 Reading MaxQuantâ€™s protein groups file)
# Read the proteinGroups file from MaxQuant directly, and immediately turn it into something useful for Proteus
prot.filename <- "/Users/cameronridderikhoff/Documents/CMPUT399/BioInformatics_Protiens_Peptides/proteus_data/practice_data_files/TP_XYZ/txt/proteinGroups.txt"
prot.PG <- readProteinGroups(prot.filename, meta) # PG stands for Protein Groups

#SECTION: Remove the proteins that don't show up in a minimum of 2 samples in one condition
dat <- prot.PG$tab # Create a shorthand for the data, so it's easier to type
to_remove <- c() # Create a list to hold the indices of the rows we need to remove
num_conditions <- length(conditions) 
for (i in 1:nrow(dat)) { # For every row, check to see if the number of occurences in each sample is >= 2
  in_sample <- 0 # Reset the number of non-null values in a sample when we move to a new row  
  keep_row <- FALSE # This variable tells the program whether or not we keep this row
  
  for (cond_samp in 1:(num_conditions*num_samples)) { # Go through every entry in the row
    if (!(is.na(dat[i, cond_samp]) | is.nan(dat[i, cond_samp]))) {
      in_sample <- in_sample + 1 # If the item is a number, that means we have one more occurence in this sample
    }
    if(in_sample >= 2) { # Anytime we have 2 or more occurences in the sample, we move on to the next row
      keep_row <- TRUE # dont remove this row
      break # "break" is a keyword, which means stop the loop. In this case, we get out of the inner for loop, and move on to the if statement on line 63
    }
    else if (cond_samp %% num_samples == 0){ # if we are at the last sample of this condition, and we haven't gotten 2 or more occurences, reset in_sample, and try the next condition
      in_sample <- 0
    }
  } # end of inner loop
  
  if (keep_row == FALSE) { # This is where "keep_row" becomes useful. If it is false, add this row number to the list of rows we want to remove.
    to_remove <- c(to_remove, i)
  }
} # end of outer loop

if (length(to_remove) > 0) { # If there are any rows to remove, remove them.
  dat <- dat[-to_remove, ]
} 
prot.PG$tab <- dat # to make use of the shorthand we change prot.PG to have the same data as "dat"


#SECTION: Plot graphs of data
#Note: ggsave saves the graph to a file in the "/outputs" folder

# Plot histogram and boxplot of log2 transformed data 
plot <- plotSampleDistributions(prot.PG, method = "dist", log.base = 2) #plots histogram plots of the intensities/ratios of each sample
ggsave(plot, file=paste('/Users/cameronridderikhoff/Documents/CMPUT399/BioInformatics_Protiens_Peptides/outputs/',
                        "log2histogram", ".png", sep=''), scale=2)

plot <- plotSampleDistributions(prot.PG, log.base = 2) #plots box plots of the intensities/ratios of each sample
ggsave(plot, file=paste('/Users/cameronridderikhoff/Documents/CMPUT399/BioInformatics_Protiens_Peptides/outputs/',
                        "log2boxplot", ".png", sep=''), scale=2)


#perform log2 transformation on the data so we can do scatterplots
prot.dat <- data.frame(log2(prot.PG$tab))
# i <- 0 TODO: Cleanup
for (condition in conditions) { # For every condition that we have:
  for (sample in 1:num_samples) { # For every sample in each condition:
    # This part is a bit complicated. In order to not have multiple copies of the same graph, ie 2vs3 and 3vs2, 
    # we start from the sample number we are at, and reiterate over the rest of the samples
    for (sample_against in sample:num_samples) { 
      if (sample_against != sample) { # make sure we are not graphing a sample against itself
        # Create the scatterplot of the log2 transformed data
        plot <- ggplot(prot.dat, aes(pull(prot.dat, sample), pull(prot.dat, sample_against))) + geom_point()
        # save plots as .pdf
        ggsave(plot, file=paste('/Users/cameronridderikhoff/Documents/CMPUT399/BioInformatics_Protiens_Peptides/outputs/',
                              condition, "_", "sample", sample, "_vs_", sample_against, ".png", sep=''), scale=2)
      }
    }
  }
  #i <- i + length(num_samples) TODO: Cleanup
}

#save the pheatmap to a png
prot.dat[is.na(prot.dat)] <- 0 # n/a's, must be 0's for pheatmap to work
pheatmap(prot.dat, show_rownames = FALSE, filename = paste('/Users/cameronridderikhoff/Documents/CMPUT399/BioInformatics_Protiens_Peptides/outputs/',
                                            conditions[i], "_", "Results_BH", "_Pheatmap.png", sep=''))


# limma package link: http://bioconductor.org/packages/release/bioc/html/limma.html
# Before limma is called, intensity data are transformed using log2. To change this to log10, replace with
# res <- limmaDE(prodat.med, transform.fun=log10)
# Perform differential expression on the normalized protein data
# This function can only be used on 2 conditions at a time. 

for (i in 1:length(conditions)) { # For each condition:
  if (conditions[i] != control_condition) { # Exclude the control condition
    
    # Call limmaDE_adjust to get p-values for the differential expression altered data
    results_BH <- limmaDE_adjust(prot.PG, conditions = c(control_condition, conditions[i]), limma_adjust = "BH")
    # Save the results in a csv file.
    write.csv(results_BH, file = paste('/Users/cameronridderikhoff/Documents/CMPUT399/BioInformatics_Protiens_Peptides/outputs/',
                                       "results", control_condition, "_vs_", conditions[i], ".csv"))
    
    # plot the unadjusted p values using a Volcano Plot and save to a png and a pdf:
    plot <- plotVolcano_pvalue(results_BH, pval = 0.05, pval_type = "unadjusted")
    ggsave(plot, file=paste('/Users/cameronridderikhoff/Documents/CMPUT399/BioInformatics_Protiens_Peptides/outputs/',
                      conditions[i], "_", "Results_BH", "_unadjusted_pvalue", "_VolcanoPlot.png", sep=''), scale=2)
    ggsave(plot, file=paste('/Users/cameronridderikhoff/Documents/CMPUT399/BioInformatics_Protiens_Peptides/outputs/',
                            conditions[i], "_", "Results_BH", "_unadjusted_pvalue", "_VolcanoPlot.pdf", sep=''), scale=2)
    
    # plot the adjusted p values using a Volcano Plot and save to a png and a pdf:
    plot <- plotVolcano_pvalue(results_BH, pval = 0.05, pval_type = "adjusted")
    ggsave(plot, file=paste('/Users/cameronridderikhoff/Documents/CMPUT399/BioInformatics_Protiens_Peptides/outputs/',
                            conditions[i], "_", "Results_BH", "_adjusted_pvalue", "_VolcanoPlot.png", sep=''), scale=2)
    ggsave(plot, file=paste('/Users/cameronridderikhoff/Documents/CMPUT399/BioInformatics_Protiens_Peptides/outputs/',
                            conditions[i], "_", "Results_BH", "_adjusted_pvalue", "_VolcanoPlot.pdf", sep=''), scale=2)
    
    # Changing the limma_adjust to none seems to have little to no effect on the result, which is why this code is currently commented out.
    #results_None <- limmaDE_adjust(prot.PG, conditions = c(control_condition, conditions[i]), limma_adjust = "none")
    #plot <- plotVolcano_pvalue(results_None, pval = 0.05)
    #ggsave(plot, file=paste('/Users/cameronridderikhoff/Documents/CMPUT399/BioInformatics_Protiens_Peptides/outputs/',
    #                        conditions[i], "_", "Results_None","_VolcanoPlot.png", sep=''), scale=2)
  }
}
#TODO
#1. Add a column with regular p-value as well (need to alter the limmaDE function from Proteus)
#Might be called "p-value" for uncorrected and q-value for corrected
#Volcano plot function only plots P-value, so we need to check the data frame
#2. Make a spreadsheet of limma_adjusted data (CSV) - do just one before trying to merge, may want to merge the two together 
#we want: NO_Phos median, Phos average, Phi average, AGI, Description
#use this data to perform PHEATMAP, KEGG, and SetRank


#SECTION: SetRank
# Generate entregeneIDs. Based on code from David_By_Pass
# Define the mart. For Arabidopsis:
mart = useMart(biomart = "plants_mart",host="plants.ensembl.org", dataset = "athaliana_eg_gene")

# Take the AGI names from results_BH
AGIs <- as.character(results_BH$protein)

# Retrieve the entregeneIDs from biomaRt, by performing a getBM query. 
# If this does not work and gives an error, ensure that "entrezgene_id" and "tair_locus_model" are correctly attributes by typing:
# >"listAttributes(mart)
AGItoEntrez <- getBM(attributes = c("entrezgene_id", "tair_locus_model"), filters = "tair_locus_model", values = AGIs, mart = mart)

# Sort the data according to pvalue:
colnames(AGItoEntrez)[2] <- "protein"
AGIentrezNpval <- merge(results_BH[, c("protein", "P.Value")], AGItoEntrez[, c("protein", "entrezgene_id")])
AGIentrezNpvalsorted <- AGIentrezNpval[order(AGIentrezNpval$P.Value),]
entrezsortedFG <- as.character(AGIentrezNpvalsorted$entrezgene_id) #this is the sorted forground gene list

# If you use use.ranks=TRUE, your background and forground lists are potentially the same (otherwise you define your own BG).
BG <- entrezsortedFG

#SetRank itself
options(mc.cores=2) #Change this if you want to use more or less cores 
collection = buildSetCollection(allDBs, referenceSet = BG, maxSetSize = 500) 
save(collection, file="collection.Rda")

# Enrichment
genesetnetwork = setRankAnalysis(entrezsortedFG, collection, use.ranks = TRUE, setPCutoff = 0.01, fdrCutoff = 0.05)
exportSingleResult(genesetnetwork, entrezsortedFG, collection, "genesetnetwork")
plot.igraph(genesetnetwork)

