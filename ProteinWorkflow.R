# Cameron Ridderikhoff, University of Alberta, 2020

# To see some information pertaining to the following code,
# Run the command:
# >vignette("proteus", package="proteus")

#########
# NOTE TO USERS:
# You MUST ensure the following line contains ALL of the directory to get to, and include, "base".
# Eg. directory <- "/Users/yourusername/Documents/folder1/base"
# You MUST NOT add a trailing "/" at the end of the line, or this will not work.
# Eg. directory <- "/Users/yourusername/Documents/folder1/base/" WILL NOT WORK.
directory <- ""
#########

#SECTION: Imports
# libary(x) tells R what library, or set of functions, it needs to use.

library(proteus) # For proteus functions like: readProteinGroups, limmaDE, and more.
library(ggplot2) # For scatter, box, and Volcano plots, and saving of the plots.
library(dplyr) # dplyr contains many helper functions required for this code.
library(pheatmap) # For the creation of a pheatmap.
library(SetRank) # For creating gene enrichment statistics.
library(biomaRt) # To help with SetRank, converts AGI protein IDs to Entrez.
# To help with SetRank, these Genesets are required, and must be generated by the user. 
# To learn how to generate this, run the command:
# >??SetRank
# and select the SetRank::vignette. Go to section 3.1.1, "Using the GeneSets package"
library(GeneSets.Arabidopsis.thaliana) 

# Import the modified functions created for this script
source("functions.R")

# Import the conditions and number of samples from the Python script that runs this workflow "run_proteus_workflow.py"
args <- commandArgs()
conditions <- args[-(1:9)] # exclude the entries not pertaining to input values
control_condition <- args[9] # the control condition is located at index 9
num_samples <- strtoi(args[8]) # the number of samples is located at index 8, turn it from a string to an integer


#SECTION: Read input data

# Read the metadata file
meta <- read.delim(paste(directory, "/data/meta.txt", sep = ""), header = TRUE, sep = "\t", dec = ".")

# (Section 5.5 Reading MaxQuantâ€™s protein groups file)
# Read the proteinGroups file from MaxQuant directly, and immediately turn it into something useful for Proteus
prot.filename <- paste(directory, "/data/proteinGroups.txt", sep = "")
prot.PG <- readProteinGroups(prot.filename, meta) # PG stands for Protein Groups


#SECTION: Remove the proteins that don't show up in a minimum of 2 samples in one condition

dat <- prot.PG$tab # Create a shorthand for the data, so it's easier to type
to_remove <- c() # Create a list to hold the indices of the rows we need to remove
num_conditions <- length(conditions) 
for (i in 1:nrow(dat)) { # For every row, check to see if the number of occurences in each sample is >= 2
  in_sample <- 0 # Reset the number of non-null values in a sample when we move to a new row  
  keep_row <- FALSE # This variable tells the program whether or not we keep this row
  
  for (cond_samp in 1:(num_conditions*num_samples)) { # Go through every entry in the row
    if (!(is.na(dat[i, cond_samp]) | is.nan(dat[i, cond_samp]))) {
      in_sample <- in_sample + 1 # If the item is a number, that means we have one more occurence in this sample
    }
    if(in_sample >= 2) { # Anytime we have 2 or more occurences in the sample, we move on to the next row
      keep_row <- TRUE # dont remove this row
      break # "break" is a keyword, which means stop the loop. In this case, we get out of the inner for loop, and move on to the if statement on line 63
    }
    else if (cond_samp %% num_samples == 0){ # if we are at the last sample of this condition, and we haven't gotten 2 or more occurences, reset in_sample, and try the next condition
      in_sample <- 0
    }
  } # End of inner loop
  
  if (keep_row == FALSE) { # This is where "keep_row" becomes useful. If it is false, add this row number to the list of rows we want to remove.
    to_remove <- c(to_remove, i)
  }
} # End of outer loop

if (length(to_remove) > 0) { # If there are any rows to remove, remove them.
  dat <- dat[-to_remove, ]
} 
prot.PG$tab <- dat # To make use of the shorthand we change prot.PG$tab to have the same data as "dat"


#SECTION: Plot graphs of data
#Note: ggsave saves the graph to a file in the "/outputs" folder

# Plot histogram and boxplot of log2 transformed data 
plot <- plotSampleDistributions(prot.PG, method = "dist", log.base = 2) # Plot histogram plots of the intensities/ratios of each sample
ggsave(plot, file=paste(directory, "/outputs/protein_log2_histogram.png", sep=''), scale=2)

plot <- plotSampleDistributions(prot.PG, log.base = 2) # Plot box plots of the intensities/ratios of each sample
ggsave(plot, file=paste(directory, "/outputs/protein_log2_boxplot.png", sep=''), scale=2)


# Perform log2 transformation on the data so we can do scatterplots
prot.dat <- data.frame(log2(prot.PG$tab))
for (condition in conditions) { # For every condition that we have:
  for (sample in 1:num_samples) { # For every sample in each condition:
    # This part is a bit complicated. In order to not have multiple copies of the same graph, ie 2vs3 and 3vs2, 
    # we start from the sample number we are at, and reiterate over the rest of the samples
    for (sample_against in sample:num_samples) { 
      if (sample_against != sample) { # Make sure we are not graphing a sample against itself
        # Create the scatterplot of the log2 transformed data
        plot <- ggplot(prot.dat, aes(pull(prot.dat, sample), pull(prot.dat, sample_against))) + geom_point()
        # Save plots as .png
        ggsave(plot, file=paste(directory, "/outputs/protein_", condition, "_sample", sample, 
                                "_vs_", sample_against, ".png", sep=''), scale=2)
      }
    }
  }
}

# Save the pheatmap to a .png
prot.dat[is.na(prot.dat)] <- 0 # n/a's, must be 0's for pheatmap to work
pheatmap(prot.dat, show_rownames = FALSE, filename = paste(directory, "/outputs/proteins_pheatmap.png", sep=''))


# Limma package link: http://bioconductor.org/packages/release/bioc/html/limma.html
# Before limma is called, intensity data are transformed using log2. To change this to log10, replace with
# results_BH <- limmaDE_adjust(prot.PG, transform.fun=log10, conditions = c(control_condition, conditions[i]), limma_adjust = "BH")
# Perform differential expression on the normalized protein data
# This function can only be used on 2 conditions at a time. 

for (i in 1:length(conditions)) { # For each condition:
  if (conditions[i] != control_condition) { # Exclude the control condition
    
    # Call limmaDE_adjust to get p-values for the differential expression altered data
    results_BH <- limmaDE_adjust(prot.PG, conditions = c(control_condition, conditions[i]), limma_adjust = "BH")
    # Save the results in a csv file.
    write.csv(results_BH, file = paste(directory, "/outputs/protein_results", 
                                       control_condition, "_vs_", conditions[i], ".csv"))
    
    # Plot the unadjusted p values using a Volcano Plot and save to a png and a pdf:
    plot <-  plotVolcano_pvalue(results_BH, pval = 0.05, pval_type = "unadjusted")
    ggsave(plot, file=paste(directory, "/outputs/protein_", conditions[i], 
                            "_BH_unadjusted_p_volcano.png", sep=''), scale=2)
    ggsave(plot, file=paste(directory, "/outputs/protein_", conditions[i], 
                            "_BH_unadjusted_p_volcano.pdf", sep=''), scale=2)
    
    # Plot the adjusted p values using a Volcano Plot and save to a png and a pdf:
    plot <- plotVolcano_pvalue(results_BH, pval = 0.05, pval_type = "adjusted")
    ggsave(plot, file=paste(directory, "/outputs/protein_", conditions[i],
                            "_BH_adjusted_pv_volcano.png", sep=''), scale=2)
    ggsave(plot, file=paste(directory, "/outputs/protein_", conditions[i], 
                            "_BH_adjusted_pv_volcano.pdf", sep=''), scale=2)
    
    # Changing the limma_adjust to none seems to have little to no effect on the result, which is why this code is currently commented out.
    #results_None <- limmaDE_adjust(prot.PG, conditions = c(control_condition, conditions[i]), limma_adjust = "none")
    #plot <- plotVolcano_pvalue(results_None, pval = 0.05)
    #ggsave(plot, file=paste('/Users/cameronridderikhoff/Documents/CMPUT399/BioInformatics_Protiens_Peptides/outputs/',
    #                        conditions[i], "_", "Results_None","_VolcanoPlot.png", sep=''), scale=2)
  }
}
#TODO
#2. Make a spreadsheet of limma_adjusted data (CSV) - do just one before trying to merge, may want to merge the two together 
# we want: NO_Phos median, Phos average, Phi average, AGI, Description


#SECTION: SetRank

# Generate entregeneIDs. Based on code from David_By_Pass
# Define the mart. For Arabidopsis:
mart = useMart(biomart = "plants_mart",host="plants.ensembl.org", dataset = "athaliana_eg_gene")

# Take the AGI names from results_BH
AGIs <- as.character(results_BH$protein)

# Retrieve the entregeneIDs from biomaRt, by performing a getBM query. 
# If this does not work and gives an error, ensure that "entrezgene_id" and "tair_locus_model" are correctly attributes by running the command:
# ">listAttributes(mart)"
AGItoEntrez <- getBM(attributes = c("entrezgene_id", "tair_locus_model"), filters = "tair_locus_model", values = AGIs, mart = mart)

# Sort the data according to pvalue:
colnames(AGItoEntrez)[2] <- "protein"
AGIentrezNpval <- merge(results_BH[, c("protein", "P.Value")], AGItoEntrez[, c("protein", "entrezgene_id")])
AGIentrezNpvalsorted <- AGIentrezNpval[order(AGIentrezNpval$P.Value),]
entrezsortedFG <- as.character(AGIentrezNpvalsorted$entrezgene_id) #this is the sorted forground gene list

# If you use use.ranks=TRUE, your background and forground lists are potentially the same (otherwise you define your own BG).
BG <- entrezsortedFG

# SetRank itself
options(mc.cores=2) #Change this if you want to use more or less cores 
collection = buildSetCollection(allDBs, referenceSet = BG, maxSetSize = 500) 
save(collection, file="collection.Rda")

# Enrichment
genesetnetwork = setRankAnalysis(entrezsortedFG, collection, use.ranks = TRUE, setPCutoff = 0.01, fdrCutoff = 0.05)
exportSingleResult(genesetnetwork, entrezsortedFG, collection, "genesetnetwork")
plot.igraph(genesetnetwork)

